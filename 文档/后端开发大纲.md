# **情侣记仇小程序 - Java后端开发大纲 (Spring Boot 3 & Java 24)**

**版本**: 2.1.0
**核心技术栈**: Java 24, Spring Boot 3.3+, Spring Security 6, PostgreSQL, JPA/Hibernate, Flyway, Docker

---

## **1. 核心技术选型 (Technology Stack)**

-   **核心框架 (Core Framework)**: **Spring Boot 3.3+** - 提供强大的自动化配置、依赖管理和生产级特性，充分利用虚拟线程（Project Loom）提升I/O密集型应用的吞吐量。
-   **开发语言 (Language)**: **Java 24** - 采用最新的LTS后继版本，站在技术的最前沿，利用预览功能和最新的语言特性（如增强的模式匹配、流收集器等）编写更现代化、高效的代码。
-   **数据持久化 (Data Persistence)**: **Spring Data JPA (Hibernate)** - 业界标准的ORM框架，通过Repository接口极大简化数据访问层的代码。
-   **数据库 (Database)**: **PostgreSQL** - 功能强大、稳定可靠的开源对象关系数据库，支持JSONB等高级数据类型。
-   **数据库迁移 (DB Migration)**: **Flyway** - 以纯SQL方式管理数据库版本，脚本化、版本化，保证各环境数据库结构的一致性。
-   **安全框架 (Security)**: **Spring Security 6.x** - 以安全过滤器链（`SecurityFilterChain`）为核心，声明式地保护API，实现基于JWT的无状态认证授权。
-   **API文档 (API Docs)**: **SpringDoc OpenAPI** - 零配置集成，自动根据代码（Controller、DTO注解）生成并提供交互式API文档(Swagger UI)。
-   **数据校验 (Validation)**: **Spring Validation (Hibernate Validator)** - JSR 380（Bean Validation）标准实现，通过注解（如`@NotBlank`, `@Size`）保证进入业务逻辑前的数据完整性。
-   **对象映射 (DTO Mapping)**: **MapStruct** - 高性能的Java Bean映射器，通过注解在编译期生成类型安全的映射代码，避免手写转换逻辑和运行时反射开销。
-   **构建工具 (Build Tool)**: **Maven 3.9.9** - 成熟可靠的项目管理和构建工具。
-   **任务调度 (Scheduling)**: **Spring Scheduling (`@Scheduled`)** - Spring内置的轻量级定时任务框架，通过Cron表达式定义周期性任务。
-   **容器化 (Containerization)**: **Docker & Docker Compose** - 实现标准化、可移植的部署，隔离环境依赖。
-   **日志 (Logging)**: **SLF4J & Logback** - Spring Boot默认的日志门面和实现，功能强大，配置灵活。

---

## **2. 项目核心包结构 (Package Structure)**

```
/com/yourcompany/couplesapp
├── CouploveApplication.java    # Spring Boot 启动类 (@SpringBootApplication)
├── config/                     # 全局配置类
│   ├── SecurityConfig.java     # Spring Security核心配置 (@Configuration, @EnableWebSecurity)
│   ├── WebConfig.java          # Web相关配置 (如全局CORS映射)
│   └── OpenApiConfig.java      # SpringDoc OpenAPI元数据配置 (如API标题、描述)
├── security/                   # Spring Security扩展
│   ├── jwt/                    # JWT相关工具与过滤器
│   │   ├── JwtProvider.java    # 生成和验证JWT Token的工具类 (@Component)
│   │   └── JwtAuthFilter.java  # 从请求头提取Token并设置认证上下文 (继承 OncePerRequestFilter)
│   └── UserDetailsServiceImpl.java # 实现UserDetailsService接口，加载用户信息 (@Service)
├── model/                      # 数据模型
│   ├── entity/                 # 数据库表对应的JPA实体类 (如 User, Couple, Event) (@Entity)
│   └── enums/                  # 枚举类型 (如 AccessStatus, EventType)
├── dto/                        # 数据传输对象 (使用Java Record提高不变性和简洁性)
│   ├── request/                # 请求体DTO (如 CreateEventRequest.java)
│   └── response/               # 响应体DTO (如 UserProfileResponse.java)
├── repository/                 # Spring Data JPA Repositories
│   └── UserRepository.java     # (继承 JpaRepository<User, UUID>) (@Repository)
├── service/                    # 业务逻辑层接口
│   ├── impl/                   # Service实现类
│   │   └── UserServiceImpl.java
│   └── UserService.java
├── controller/                 # API控制器
│   ├── UserController.java     # (@RestController, @RequestMapping("/api/users"))
│   └── GlobalExceptionHandler.java # (@RestControllerAdvice)，全局异常处理
├── mapper/                     # MapStruct 映射接口
│   └── UserMapper.java         # (@Mapper(componentModel = "spring"), 定义DTO与Entity的转换)
└── scheduler/                  # 定时任务
    └── AppScheduler.java       # (@Component, @Scheduled)
```

---

## **3. 详细开发步骤与任务分解**

### **第一阶段：项目初始化与基础架构**

1.  **项目生成**:
    -   使用 **Spring Initializr** (`start.spring.io`) 生成项目骨架。选择Java 24, Maven。
    -   添加依赖：`Spring Web`, `Spring Data JPA`, `PostgreSQL Driver`, `Spring Security`, `Validation`, `Lombok`, `Spring Boot Actuator`, `Flyway Migration`。
2.  **环境配置**:
    -   在 `src/main/resources/application.yml` 中配置数据源（URL, username, password）、服务器端口、JPA/Hibernate属性（如`ddl-auto: validate`）、Flyway (`enabled: true`) 以及自定义的JWT密钥和有效期。
3.  **数据库迁移 (Flyway)**:
    -   在 `src/main/resources/db/migration` 目录下创建第一个SQL迁移文件 `V1__init_schema.sql`。
    -   根据 `数据库设计.md` 编写所有表的 `CREATE TABLE` 语句，包括主键、外键、索引和约束。
4.  **模型与仓库**:
    -   在 `model/entity` 包下创建所有JPA实体类。使用 `@Entity`, `@Table`, `@Id`, `@Column`, `@ManyToOne`, `@Enumerated(EnumType.STRING)` 等注解精确映射数据库表。使用 Lombok (`@Getter`, `@Setter`, `@Builder`, `@NoArgsConstructor`, `@AllArgsConstructor`) 减少样板代码。
    -   在 `repository` 包下为每个实体创建对应的JPA Repository接口，继承 `JpaRepository`。
5.  **全局异常处理**:
    -   创建 `GlobalExceptionHandler` 类。
    -   使用 `@ExceptionHandler(SpecificException.class)` 定义处理特定异常的方法，例如：
        -   `MethodArgumentNotValidException`: 处理DTO校验失败，返回400。
        -   `AccessDeniedException`: 处理权限不足，返回403。
        -   自定义的 `ResourceNotFoundException`: 返回404。
    -   所有处理方法都返回一个统一的 `ErrorResponse` DTO，与 `后端api文档.md` 中约定的结构一致。

### **第二阶段：安全框架与核心认证**

1.  **Spring Security 配置 (`SecurityConfig.java`)**:
    -   定义 `SecurityFilterChain` Bean。
    -   使用Lambda DSL配置: `http.csrf(AbstractHttpConfigurer::disable)`...
    -   配置会话管理为无状态: `session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)`。
    -   配置请求授权规则: `authorizeHttpRequests.requestMatchers("/api/auth/**").permitAll().anyRequest().authenticated()`。
2.  **JWT 实现**:
    -   **`JwtProvider.java`**: 使用 `jjwt` 库。包含 `generateToken(Authentication auth)` 和 `validateToken(String token)` 方法。
    -   **`JwtAuthFilter.java`**: 在 `doFilterInternal` 方法中：从请求头获取`Authorization: Bearer <token>` -> 调用 `JwtProvider` 验证 -> 如果有效，从Token中解析出用户ID/角色，创建 `UsernamePasswordAuthenticationToken` -> 通过 `SecurityContextHolder.getContext().setAuthentication(...)` 设置认证。
    -   在 `SecurityConfig` 中，使用 `http.addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)` 将自定义过滤器添加到过滤器链。
3.  **用户服务集成 (`UserDetailsServiceImpl.java`)**:
    -   实现 `loadUserByUsername(String username)` 方法。`username` 在此场景下通常是用户的唯一标识（如ID或OpenID）。方法从数据库加载 `User` 实体，并将其转换为一个实现了 `UserDetails` 接口的自定义对象（或直接使用Spring Security的 `User` 类）。
4.  **核心接口实现 (`UserController.java`)**:
    -   实现 `GET /api/me`。方法参数中使用 `@AuthenticationPrincipal UserDetails userDetails` 直接获取当前登录的用户信息，从而查询并构建完整的会话响应。

### **第三阶段：核心业务逻辑**

1.  **模块化开发**: 为 `couples`, `events`, `sweet-messages` 等每个功能模块创建对应的 `Controller`, `Service` 接口, `ServiceImpl` 实现, `Repository`, DTOs 和 `Mapper`。
2.  **Service 层 (`@Service`)**:
    -   所有业务逻辑在此实现。通过构造函数注入其他 Service 或 Repository。
    -   对所有会改变数据的方法（CUD操作）添加 `@Transactional` 注解。对于复杂操作（如接受邀请），确保整个方法在一个事务中完成。
3.  **Controller 层 (`@RestController`)**:
    -   只负责HTTP层面的交互。注入 `Service` 并调用其方法。
    -   方法参数上使用 `@Valid @RequestBody DTO dto` 来接收和自动验证请求体。
4.  **DTO 与实体映射 (`MapStruct`)**:
    -   引入 `mapstruct` 和 `mapstruct-processor` 依赖。
    -   为每个模块创建 `Mapper` 接口（如`EventMapper.java`），通过 `@Mapping(source = "entity.field", target = "dto.field")` 注解定义映射规则。编译时会自动生成实现类，IDE可以直接跳转。

### **第四阶段：订阅与高级功能**

1.  **高级查询**: 在 `AnalyticsService` 中，可能需要复杂的数据聚合。在对应的 Repository 中使用 `@Query` 注解编写 **JPQL** (`SELECT new com.yourcompany.dto.AnalyticResult(...) FROM ...`)，直接将查询结果映射到DTO，避免了不必要的实体加载和转换，性能更优。
2.  **异步与通知**:
    -   在主启动类上添加 `@EnableAsync`。
    -   `NotificationsService` 的 `createNotification` 方法标记为 `@Async`，使其在独立的线程中执行，避免阻塞主业务流程（如发帖操作）。
3.  **定时任务 (`@Scheduled`)**:
    -   创建 `AppScheduler.java`，添加 `@EnableScheduling` 到主启动类。
    -   使用 `@Scheduled(cron = "${app.scheduler.subscription-check-cron}")` 定义任务。将Cron表达式配置在 `application.yml` 中，方便不同环境（开发、生产）使用不同的执行频率。

### **第五阶段：测试、部署与生产准备**

1.  **测试**:
    -   **单元测试**: 使用 JUnit 5 和 Mockito (`@Mock`, `@InjectMocks`) 测试 Service 层，隔离外部依赖（如Repository）。
    -   **集成测试**: 使用 `@SpringBootTest` 和 `MockMvc` 或 `RestAssured` 测试 Controller 层。可以使用 `@Sql` 注解在测试方法执行前加载特定的SQL脚本来准备测试数据。
2.  **Docker化**:
    -   在 `Dockerfile` 中使用 **Maven多阶段构建**：
        -   `FROM maven:3.9.9-eclipse-temurin-24 as builder` -> 构建阶段
        -   `FROM eclipse-temurin:24-jre` -> 运行阶段
        -   仅复制编译好的 `.jar` 文件和依赖，极大减小最终镜像体积。
    -   `docker-compose.yml` 用于本地开发，一键启动 `app` 服务和 `postgres` 数据库服务，并配置好网络和环境变量。
3.  **生产准备**:
    -   **API 文档**: 集成 `springdoc-openapi-starter-webmvc-ui`，启动后即可通过 `/swagger-ui.html` 访问交互式API文档。
    -   **监控与健康检查**: `Spring Boot Actuator` 默认提供了 `/actuator/health`, `/actuator/info` 等端点，可集成到Prometheus等监控系统。
    -   **安全**: 确保所有敏感配置（数据库密码，JWT密钥）都通过**环境变量**或**Docker Secrets/K8s Secrets**注入，绝不硬编码在代码或配置文件中。
