# **恋心物语 - 原生微信小程序前端开发文档**

**版本**: 1.0.0
**核心技术栈**: 微信小程序原生框架 (WXML, WXSS, JavaScript/TypeScript), Mobx-miniprogram
**后端API版本**: 1.0.0

---

## **第一部分：项目架构与开发规范**

### **1. 核心技术选型 (Technology Stack)**

-   **框架 (Framework)**: **原生微信小程序框架** - 使用微信官方提供的高性能、最稳定的开发模式。
-   **语言 (Language)**: **TypeScript** - 为整个项目提供强大的类型约束，提升代码健壮性和可维护性。
-   **状态管理 (State Management)**: **mobx-miniprogram** + **mobx-miniprogram-bindings** - 提供一个响应式、可预测、且对原生小程序友好的全局状态管理方案，易于上手且功能强大。
-   **UI框架 (UI Framework)**: **自定义组件** - 为保证最佳性能和设计统一性，我们将不依赖第三方UI库，所有UI组件均根据原型图手写实现。
-   **开发工具 (IDE)**: **微信开发者工具** - 使用官方IDE进行开发、调试、预览和发布。

### **2. 项目结构 (Directory Structure)**

项目代码将存放于 `/miniapp` 目录中，其结构遵循官方推荐的最佳实践，清晰地分离了页面、组件、服务和状态。

```
miniapp/
├── app.js                 # 小程序入口逻辑，初始化全局状态
├── app.json               # 小程序全局配置 (页面、窗口、tabBar)
├── app.wxss               # 全局公共样式
├── project.config.json    # 开发者工具项目配置
├── sitemap.json           # 站点地图配置
├── static/                # 静态资源 (图片、字体等)
│   ├── icons/
│   └── images/
├── pages/                 # 【业务】页面模块
│   ├── index/             # 首页 (爱情指数)
│   │   ├── index.js
│   │   ├── index.json
│   │   ├── index.wxml
│   │   └── index.wxss
│   ├── events/            # 事件模块 (列表/新增/详情)
│   ├── mood/              # 心情分析模块
│   ├── sweet/             # 甜蜜留言板模块
│   ├── profile/           # 个人中心模块
│   ├── couple/            # 情侣绑定模块
│   └── auth/              # 认证 (登录) 模块
├── components/            # 【业务】可复用UI组件
│   ├── EventItem/         # 示例：事件条目组件
│   │   ├── index.js
│   │   ├── index.json
│   │   ├── index.wxml
│   │   └── index.wxss
│   └── ...                # 其他自定义组件
├── services/              # 【核心】服务层，封装API请求
│   ├── api.js             # 底层封装 wx.request
│   └── user.js            # 用户、情侣关系、订阅等API
├── store/                 # 【核心】全局状态管理 (MobX)
│   ├── user.js            # 用户及情侣关系状态
│   └── event.js           # 事件/留言等内容状态
├── types/                 # 【核心】TypeScript 全局类型定义
│   ├── api.ts
│   └── index.ts
└── utils/                 # 【核心】工具函数
    ├── util.js            # 通用工具函数 (日期格式化等)
    └── constants.js       # 全局常量 (API基地址等)
```

### **3. 编码规范 (Coding Standards)**

-   **代码风格**: 遵循 `ESLint` (推荐 `eslint-config-airbnb-base`) + `Prettier`。
-   **命名规范**:
    -   JS/TS 文件、WXML/WXSS 文件: `kebab-case` (e.g., `event-item.js`) 或 `camelCase` (e.g., `eventItem.js`)，项目内保持统一。
    -   组件文件夹: `PascalCase` (e.g., `EventItem/`)
    -   变量/函数: `camelCase` (e.g., `fetchEvents`)。
    -   常量: `UPPER_CASE` (e.g., `API_BASE_URL`)。
-   **Git提交规范**: 遵循 `Conventional Commits` 规范。

### **4. TypeScript 类型定义 (`types/`)**

根据后端API文档，定义所有核心数据模型。这部分与之前的定义保持一致。

**`types/index.ts`**
```typescript
// 用户信息
export interface UserInfo {
  id: string;
  nickname: string;
  avatar_url: string;
  bio: string;
  role: 'USER' | 'ADMIN';
}

// 情侣关系信息
export interface CoupleInfo {
  id: string;
  anniversary_date: string;
  connection_score: number;
  trial_ends_at: string | null;
  subscription_expires_at: string | null;
  status: 'active' | 'unbound';
}

// 事件/帖子信息
export interface EventItem {
  id: string;
  author: UserInfo;
  type: 'GRUDGE' | 'SWEET';
  description: string;
  images: string[] | null;
  mood_tag: MoodTag;
  status: 'unresolved' | 'resolved';
  event_date: string;
  created_at: string;
}

// 心情标签
export interface MoodTag {
  id: number;
  name: string;
  emoji_icon: string;
  score_effect: number;
}

// 甜蜜留言
export interface SweetMessage {
    id: string;
    author_nickname: string;
    message: string;
    created_at: string;
}
```

**`types/api.ts`**
```typescript
// 通用API响应结构
export interface ApiResponse<T = any> {
  code: number;
  message: string;
  data: T;
  errors?: Record<string, string>;
}

// GET /me 的响应数据
export interface MeResponse {
  access_status: 'ADMIN' | 'FULL_ACCESS' | 'TRIAL' | 'EXPIRED' | 'UNBOUND';
  currentUser: UserInfo;
  partner: UserInfo | null;
  coupleInfo: CoupleInfo | null;
}
```

---

## **第二部分：核心模块详解**

### **1. API 客户端 (`services/api.js`)**

封装 `wx.request`，实现请求拦截、Token管理、响应及错误统一处理。

```javascript
import { userStore } from '../store/user';
import { API_BASE_URL } from '../utils/constants';

const request = (options) => {
  return new Promise((resolve, reject) => {
    const token = wx.getStorageSync('access_token');

    wx.request({
      ...options,
      url: API_BASE_URL + options.url,
      header: {
        'Content-Type': 'application/json',
        'Authorization': token ? `Bearer ${token}` : '',
        ...options.header,
      },
      success(res) {
        const apiResponse = res.data;

        // Code 401: Token失效或未认证
        if (apiResponse.code === 401) {
          userStore.logout(); // 清理本地状态
          wx.reLaunch({
            url: '/pages/auth/index', // 跳转到登录页
          });
          return reject(apiResponse);
        }

        // Code 200/201: 成功
        if (apiResponse.code === 200 || apiResponse.code === 201) {
          return resolve(apiResponse.data); // 直接返回核心数据
        }
        
        // 其他业务错误
        wx.showToast({
          title: apiResponse.message || '请求失败',
          icon: 'none',
        });
        return reject(apiResponse);
      },
      fail(err) {
        wx.showToast({
          title: '网络请求异常',
          icon: 'error',
        });
        reject(err);
      },
    });
  });
};

// 便捷方法
export const api = {
  get: (url, data) => request({ url, method: 'GET', data }),
  post: (url, data) => request({ url, method: 'POST', data }),
  put: (url, data) => request({ url, method: 'PUT', data }),
  delete: (url) => request({ url, method: 'DELETE' }),
};
```

### **2. 全局状态管理 (`store/` & `app.js`)**

**`store/user.js` - 定义用户Store**
```javascript
import { observable, action } from 'mobx-miniprogram';
import { api } from '../services/api';

export const userStore = observable({
  // State
  accessStatus: 'UNBOUND',
  currentUser: null,
  partner: null,
  coupleInfo: null,
  isLoading: true,

  // Getters
  get isLoggedIn() {
    return !!this.currentUser;
  },
  get isCoupleBound() {
    return this.accessStatus !== 'UNBOUND';
  },
  get canAccessFullFeatures() {
    return ['ADMIN', 'FULL_ACCESS', 'TRIAL'].includes(this.accessStatus);
  },

  // Actions
  fetchUserSession: action(async function () {
    this.isLoading = true;
    try {
      const data = await api.get('/me');
      this.accessStatus = data.access_status;
      this.currentUser = data.currentUser;
      this.partner = data.partner;
      this.coupleInfo = data.coupleInfo;
    } catch (error) {
      console.error('会话加载失败:', error);
      // 错误处理已在api.js中完成，这里可添加额外逻辑
    } finally {
      this.isLoading = false;
    }
  }),
  
  logout: action(function () {
    wx.removeStorageSync('access_token');
    this.accessStatus = 'UNBOUND';
    this.currentUser = null;
    this.partner = null;
    this.coupleInfo = null;
  }),
});
```
**`app.js` - 注入并初始化Store**
```javascript
import { userStore } from './store/user';
import { eventStore } from './store/event';

App({
  onLaunch() {
    // 将store挂载到App实例上，方便全局访问
    this.store = {
      userStore,
      eventStore,
    };
    
    // 启动时检查Token，如果存在则尝试加载用户会话
    const token = wx.getStorageSync('access_token');
    if (token) {
      this.store.userStore.fetchUserSession();
    }
  },
});
```

### **3. 路由与权限拦截**

通过 `wx.addInterceptor` 实现，无需第三方库。

**在 `app.js` 的 `onLaunch` 中添加:**
```javascript
// ... onLaunch()
this.setupRouterInterceptor();
// ...

App({
  // ...
  setupRouterInterceptor() {
    const whiteList = ['/pages/auth/index']; // 无需登录即可访问的页面

    const interceptor = (params) => {
      const url = params.url.split('?')[0];
      // 如果未登录且目标页不在白名单内
      if (!this.store.userStore.isLoggedIn && !whiteList.includes(url)) {
        wx.showToast({ title: '请先登录', icon: 'none' });
        // 跳转到登录页
        wx.reLaunch({ url: '/pages/auth/index' });
        return false; // 阻断跳转
      }
      return params; // 放行
    };

    wx.addInterceptor('navigateTo', { invoke: interceptor });
    wx.addInterceptor('reLaunch', { invoke: interceptor });
    wx.add-interceptor('switchTab', { invoke: interceptor });
  },
  // ...
});
```

---

## **第三部分：页面开发详解 (Page-by-Page)**

### **1. 登录页 (`/pages/auth/index`)**

-   **功能描述**: 应用入口，处理微信授权登录。
-   **API调用**:
    1.  `wx.login()` 获取微信code。
    2.  `POST /auth/login` (携带code) 到后端换取JWT Token。
-   **核心逻辑 (`index.js`):**
    ```javascript
    import { createStoreBindings } from 'mobx-miniprogram-bindings';
    import { userStore } from '../../store/user';

    Page({
      onLoad() {
        this.storeBindings = createStoreBindings(this, {
          store: userStore,
          fields: ['isLoggedIn', 'isCoupleBound'],
          actions: ['fetchUserSession'],
        });
      },
      onUnload() {
        this.storeBindings.destroyStoreBindings();
      },
      async handleLogin() {
        try {
          const loginRes = await wx.login();
          if (loginRes.code) {
            const { access_token } = await api.post('/auth/login', { code: loginRes.code });
            wx.setStorageSync('access_token', access_token);
            
            await this.fetchUserSession(); // 重新加载用户数据

            // 登录成功后跳转
            if (this.data.isCoupleBound) {
              wx.reLaunch({ url: '/pages/index/index' });
            } else {
              wx.reLaunch({ url: '/pages/couple/index' });
            }
          }
        } catch (error) {
          console.error('登录失败', error);
        }
      },
    });
    ```
-   **WXML (`index.wxml`):**
    ```html
    <view class="container">
      <button type="primary" bind:tap="handleLogin">微信授权登录</button>
    </view>
    ```

### **2. 首页 (`/pages/index/index`)**

-   **功能描述**: 应用核心仪表盘，展示情侣信息、亲密度和事件列表。
-   **数据依赖**: `userStore`, `eventStore`。
-   **核心逻辑 (`index.js`):**
    ```javascript
    import { createStoreBindings } from 'mobx-miniprogram-bindings';
    import { userStore } from '../../store/user';
    import { eventStore } from '../../store/event';

    Page({
      data: {
        // WXML中可以直接使用 userStore.currentUser.nickname 这样的语法
      },
      onLoad(options) {
        // 绑定两个store
        this.storeBindings = createStoreBindings(this, {
          store: null, // 同时绑定多个store时，这里设为null
          fields: {
            // 将store中的字段映射到页面的data
            userStore: () => userStore,
            eventStore: () => eventStore
          },
          actions: {
            fetchUnresolvedEvents: 'fetchUnresolvedEvents', // 绑定action
          },
        });
      },
      onShow() {
        // 每次进入页面都刷新数据
        this.fetchUnresolvedEvents();
        // user session在app.js中处理，或在此处再次调用
        // getApp().store.userStore.fetchUserSession();
      },
      onUnload() {
        this.storeBindings.destroyStoreBindings();
      },
      onAddEventTap() {
        wx.navigateTo({ url: '/pages/events/add' });
      }
    });
    ```
-   **WXML (`index.wxml`)**
    ```html
    <!-- 加载状态 -->
    <view wx:if="{{userStore.isLoading}}">加载中...</view>
    
    <!-- 主内容 -->
    <block wx:else>
      <!-- 未绑定情侣 -->
      <view wx:if="{{!userStore.isCoupleBound}}">
        <text>请先绑定您的另一半</text>
        <button bind:tap="goToBindPage">去绑定</button>
      </view>

      <!-- 已绑定 -->
      <view wx:else>
        <view class="header">
          <!-- 头像、昵称等 -->
          <image src="{{userStore.currentUser.avatar_url}}"></image>
          <text>{{userStore.currentUser.nickname}}</text>
          <!-- 亲密度进度条组件 -->
          <ProgressBar score="{{userStore.coupleInfo.connection_score}}" />
        </view>
        
        <!-- 事件列表 -->
        <view class="event-list">
          <block wx:for="{{eventStore.unresolvedEvents}}" wx:key="id">
            <EventItem event="{{item}}" />
          </block>
        </view>
      </view>
    </block>
    
    <!-- 悬浮新增按钮 -->
    <view class="fab" bind:tap="onAddEventTap">+</view>
    ```

---

## **第四部分：开发与部署**

### **1. 自定义组件**

-   在 `components` 目录下创建组件文件夹，例如 `EventItem`。
-   在 `EventItem/index.js` 中使用 `Component({})` 构造器创建组件。
-   在 `EventItem/index.json` 中声明 `component: true`。
-   在需要使用组件的页面的 `json` 文件中，通过 `usingComponents` 字段引入。

### **2. 调试与发布**

-   **调试**: 使用 **微信开发者工具** 的模拟器和真机调试功能。利用 `console.log` 和 "调试器" 面板进行代码调试。
-   **发布**:
    1.  在开发者工具中，点击右上角的 "上传"。
    2.  填写版本号和项目备注。
    3.  上传成功后，登录 [微信公众平台](https://mp.weixin.qq.com/)。
    4.  在 "版本管理" 中找到刚上传的版本，可设为体验版供内部测试。
    5.  测试无误后，提交审核。审核通过后即可发布上线。

---

**本文档为原生小程序前端开发的核心指南，所有开发活动都应严格遵循本文档定义的架构、规范和流程。**
